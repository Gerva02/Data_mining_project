}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_max_min)
return(list(train_norm=train_norm,test_norm=test_norm))
}
normalize_2(glass.train,glass.test)
#non ho runnato, devo andare a cena (incrociamo le dita)
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_max_min)
return(list(train_norm=train_norm,test_norm=test_norm))
}
normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
#non ho runnato, devo andare a cena (incrociamo le dita)
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
out<-normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
out$train_norm#mi viene da piangere, ha runnato tutto senza bug
#gervi fai un check che poi possiamo usarla
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
out<-normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
out$train_norm[1:10]
#mi viene da piangere, ha runnato tutto senza bug
#gervi fai un check che poi possiamo usarla
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
out<-normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
out$train_norm[1:10,]
#mi viene da piangere, ha runnato tutto senza bug
#gervi fai un check che poi possiamo usarla
out$train_norm[1:10,]
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
out<-normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
out$train_norm[1:10,]
out$test_norm[1:10,]
#mi viene da piangere, ha runnato tutto senza bug
#gervi fai un check che poi possiamo usarla
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
out<-normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
out$train_norm[1:10,]
out$test_norm[1:10,]
#mi viene da piangere, ha runnato tutto senza bug
#gervi fai un check che poi possiamo usarla
glass
glass
?sample
knitr::opts_chunk$set(echo = F)
knitr::opts_chunk$set(comment = NA)
library(tidyverse)
library(mclust)
library(Rmixmod)
library(GGally)
library(caret)
library("tree")
library(ggcorrplot)
library(class)
path <- "glass.csv"
glass <- tibble(read.table(path , sep = "," , header = T))
glass$Type <- factor(glass$Type)
# glass%>%
#   select(-Type) %>%
#   ggpairs(mapping = aes(color = glass$Type))
ggcorrplot(cor(glass%>%
select(-Type)), lab = T , type = "lower" )
#questo bar plot è riguardo freq relative
glass %>%
ggplot(aes(x= Type, y = after_stat(count)/sum(after_stat(count)), fill = Type)) +
geom_bar()
#questo bar plot è riguardo freq assolute
glass %>%
ggplot(aes(x= Type, y = after_stat(count), fill = Type)) +
geom_bar()
#qua devo ancora capire come farlo meglio sarebbero i box plot condizionati e ad ogni misurazione ad ogni tipo il problema è la scala di gradezza è diversa per ogni casella
glass %>%
gather(key = Measure, value = value, -Type )  %>%
ggplot(aes(x = Type, y= value, color = Measure)) +
geom_violin(trim = F)+
geom_boxplot(width=0.1) +
facet_wrap( ~ Measure ,scales = "free", ncol =2)
glass %>%
filter(Type == "6")
#qua si crea tabella pvalues
pvalue_shapiro <- matrix(0, nrow = (dim(glass)[2]-1), ncol = 6)
rownames(pvalue_shapiro) = colnames(glass)[-10]
colnames(pvalue_shapiro) = levels(glass$Type)
#-----
# Test Shapiro e costruzione di una matrice riassuntiva con i p-value condizionati alla classe
for (i in colnames(glass)[-10]){
for (j in levels(glass$Type)){
pvalue_shapiro[i,j]<-
shapiro.test( jitter(glass %>% filter(Type == j)%>%pull(i)) )$p.value #qua si assegnano tutti i valori, bisonga stare attenti perchè alcuni di questi non sono validi perchè ho messo jitter non lo fa andare in errore quando tutti i valori sono uguali ma introduce noise gaussiano che rende normali quando non sono ugugali
# pull invece serve per tirare fuori dal tibble un vettore (e non un tibble)
}
}
pvalue_shapiro["Ca", "6" ] <- pvalue_shapiro["K", "6" ] <- pvalue_shapiro["Fe", "6" ] <- NA
round(pvalue_shapiro, 5)
#questa è una funzione che divide tra test e train (magari ci serve nel CV)
dataset_division <- function(D1, perc = 0.7) {
id <- sample(size = round(perc* nrow(D1)) , x = nrow(D1))
train <- D1[id,]
test <- D1[-id,]
out <- list(train = train, test = test)
}
#Qua abbiamo diviso magari dobbiamo normalizzare
set.seed(123)
glass.train <- dataset_division(glass)$train
glass.test <- dataset_division(glass)$test
#non trovo il comando per farlo per tutto il data set senza usare apply (dovremmo fare un apply)
# ma inoltre per ogni colonna (se normalizziamo) dobbiamo salvare min e max (e dopo veranno applicati sul test)
#qua ho fatto un albero e sembra buono (migliorerà soltanto se normalizziam
set.seed(123)
tree.glass <- tree(Type ~. , glass.train)
summary(tree.glass)
plot(tree.glass); text(tree.glass, , pretty = 0) # albero completo # queste due linee vanno eseguite insieme
tree.pred <- predict(tree.glass , glass.test[-10] , type = "class")
mean(tree.pred == glass.test$Type)
set.seed (7)
cv.tree.glass <- cv.tree(tree.glass , FUN = prune.misclass)
par(mfrow = c(1, 2))
plot(cv.tree.glass$size , cv.tree.glass$dev, type = "b")
points(cv.tree.glass$size[which.min(cv.tree.glass$dev)], cv.tree.glass$dev[which.min(cv.tree.glass$dev)], col = "red", pch = 19)
plot(cv.tree.glass$k, cv.tree.glass$dev, type = "b")
best.tree <-  prune.misclass(tree.glass , best = cv.tree.glass$size[which.min(cv.tree.glass$dev)])
tree.pred <- predict(best.tree , glass.test[-10] , type = "class")
confusionMatrix(tree.pred,glass.test$Type )
mean(tree.pred == glass.test$Type)
plot(best.tree); text(best.tree,,pretty=0)
normalize <- function(x, v = NA) {
if (is.na(v)){
return((x - min(x)) / (max(x) - min(x)))
}
else{
return((x - v[1]) / (v[2] -v[1]))
}
}
set.seed(123)
norm_glass <- glass.train
min_max_matrix <- matrix(rep(NA, 18), nrow= 2 , ncol = (ncol(glass)-1) )
for (i in 1: (ncol(glass)-1)){
min_max_matrix[1 , i] <- min(norm_glass %>% pull(i))
min_max_matrix[2 , i] <- max(norm_glass %>% pull(i))
norm_glass[,i] <- normalize(norm_glass %>% pull(i))
}
norm_glass_test<-apply(glass.test %>% select(-Type), MARGIN = 2, normalize)
norm_glass
#esiste anche knn.cv !!!!!!!!!
Kmax<-20
knn.pred.k<-rep(0,Kmax)
X_train<-norm_glass %>% select(-Type)
labels<-norm_glass$Type #qua ho cambiato e non sembra essere cambiato nulla
X_test<-norm_glass_test
for (i in 1:Kmax){
set.seed(42)
knn.pred <- knn(train=X_train, test=X_test, cl=labels, k = i)
knn.pred.k[i]<-mean(knn.pred == glass.test$Type)
}
r<-rep("black",Kmax)
r[which.max(knn.pred.k)]<-"red"
plot(1:Kmax,knn.pred.k,type="h",ylim=c(0,1),col=r)
abline(h=max(knn.pred.k),col="purple") #mi sa che ho rotto qualcosa ma è un po' incoprensibile che cosa
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
out<-normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
out$train_norm[1:10,]
out$test_norm[1:10,]
#mi viene da piangere, ha runnato tutto senza bug
#gervi fai un check che poi possiamo usarla
cv<-5
n<-nrow(glass)
k<-ncol(glass)
for (i in 1:cv){
split<-sample()
}
func<-function(v){
return((v-v[1])/(v[2]-v[1]))
}
norm_aux<-function(data,matrix){
data_2<-rbind(matrix,data)
data_norm<-apply(data_2,MARGIN = 2,func)
return(data_norm[3:nrow(data_norm),])
}
normalize_2<-function(train,test){
matrix_min_max<-rbind(apply(train,MARGIN = 2,min),apply(train,MARGIN = 2,max))
train_norm<-norm_aux(train,matrix_min_max)
test_norm<-norm_aux(test,matrix_min_max)
return(list(train_norm=train_norm,test_norm=test_norm))
}
out<-normalize_2(glass.train[,-ncol(glass.train)],glass.test[,-ncol(glass.test)])
out$train_norm[1:10,]
out$test_norm[1:10,]
#mi viene da piangere, ha runnato tutto senza bug
#gervi fai un check che poi possiamo usarla
#esiste anche knn.cv !!!!!!!!!
Kmax<-20
knn.pred.k<-rep(0,Kmax)
X_train<-norm_glass %>% select(-Type)
labels<-norm_glass$Type #qua ho cambiato e non sembra essere cambiato nulla
X_test<-norm_glass_test
for (i in 1:Kmax){
set.seed(42)
knn.pred <- knn(train=X_train, test=X_test, cl=labels, k = i)
knn.pred.k[i]<-mean(knn.pred == glass.test$Type)
}
r<-rep("black",Kmax)
r[which.max(knn.pred.k)]<-"red"
plot(1:Kmax,knn.pred.k,type="h",ylim=c(0,1),col=r)
abline(h=max(knn.pred.k),col="purple") #mi sa che ho rotto qualcosa ma è un po' incoprensibile che cosa
normalize <- function(x, v = NA) {
if (is.na(v)){
return((x - min(x)) / (max(x) - min(x)))
}
else{
return((x - v[1]) / (v[2] -v[1]))
}
}
set.seed(123)
norm_glass <- glass.train
min_max_matrix <- matrix(rep(NA, 18), nrow= 2 , ncol = (ncol(glass)-1) )
for (i in 1: (ncol(glass)-1)){
min_max_matrix[1 , i] <- min(norm_glass %>% pull(i))
min_max_matrix[2 , i] <- max(norm_glass %>% pull(i))
norm_glass[,i] <- normalize(norm_glass %>% pull(i))
}
?sample
?sample
c(T,F,T)
!(c(T,F,T))
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-glass[,k]
knn.kmax<-10
tree.size.max<-15
mat<-matrix(NA,nrow=knn.kmax+tree.size.max,ncol=cv+2)
mat[1:knn.max,1]<-"knn"
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-glass[,k]
knn.kmax<-10
tree.size.max<-15
mat<-matrix(NA,nrow=knn.kmax+tree.size.max,ncol=cv+2)
mat[1:knn.kmax,1]<-"knn"
mat[knn.kmax+1:knn.kmax+tree.size.max,1]<-"tree"
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-glass[,k]
knn.kmax<-10
tree.size.max<-15
mat<-matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2)
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
mat[knn.kmax+1:knn.kmax+tree.size.max,2]<-1:tree.size.max
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-glass[,k]
knn.kmax<-10
tree.size.max<-15
mat<-as.data.frame(matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2))
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
mat[knn.kmax+1:knn.kmax+tree.size.max,2]<-1:tree.size.max
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-glass[,k]
knn.kmax<-10
tree.size.max<-15
mat<-as.data.frame(matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2))
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
#mat[knn.kmax+1:knn.kmax+tree.size.max,2]<-1:tree.size.max
mat
View(mat)
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-glass[,k]
knn.kmax<-10
tree.size.max<-15
mat<-as.data.frame(matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2))
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
mat[(knn.kmax+1):(knn.kmax+tree.size.max),2]<-1:tree.size.max
mat
mat[7:19]
mat[7:19,]
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-as.factor(as.matrix(glass[,k]))
knn.kmax<-10
tree.size.max<-15
mat<-as.data.frame(matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2))
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
mat[(knn.kmax+1):(knn.kmax+tree.size.max),2]<-1:tree.size.max
for (j in 1:cv){
split<-sample(c(T,F), size=n, replace = T, prob = c(p,1-p))
#metodo knn
for (i in 1:knn.kmax){
set.seed(42)
knn.pred <- knn(train=glass[split,-k], test=glass[!split,-k], cl=labels[split], k = i)
mat[i,j+2]<-mean(knn.pred==labels[!split])
}
}
mat
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-as.factor(as.matrix(glass[,k]))
knn.kmax<-10
tree.size.max<-15
mat<-as.data.frame(matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2))
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
mat[(knn.kmax+1):(knn.kmax+tree.size.max),2]<-1:tree.size.max
for (j in 1:cv){
split<-sample(c(T,F), size=n, replace = T, prob = c(p,1-p))
#metodo knn
for (i in 1:knn.kmax){
set.seed(42)
knn.pred <- knn(train=glass[split,-k], test=glass[!split,-k], cl=labels[split], k = i)
mat[i,j+2]<-mean(knn.pred==labels[!split])
}
#metodo alberi
for (i in 1:tree.size.max){
}
}
res<-cbind(mat[,c(1,2)],apply(mat[,3:j+2],MARGIN=1,mean))
res
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-as.factor(as.matrix(glass[,k]))
knn.kmax<-10
tree.size.max<-15
mat<-as.data.frame(matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2))
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
mat[(knn.kmax+1):(knn.kmax+tree.size.max),2]<-1:tree.size.max
for (j in 1:cv){
split<-sample(c(T,F), size=n, replace = T, prob = c(p,1-p))
#metodo knn
for (i in 1:knn.kmax){
set.seed(42)
knn.pred <- knn(train=glass[split,-k], test=glass[!split,-k], cl=labels[split], k = i)
mat[i,j+2]<-mean(knn.pred==labels[!split])
}
#metodo alberi
for (i in 1:tree.size.max){
set.seed(42) #TODO metodo previsione alberi con le varie size (GERVI TUTTO TUO)
#mat[(i+knn.kmax),j+2]<-
}
}
res<-cbind(mat[,c(1,2)],apply(mat[,3:j+2],MARGIN=1,mean)) #possiamo usare median se vogliamo
colnames(res)<-c("metodo","hyperparameter","accuracy")
res[1:12,]
cv<-5
p<-1-1/cv
n<-nrow(glass)
k<-ncol(glass)
labels<-as.factor(as.matrix(glass[,k]))
knn.kmax<-10
tree.size.max<-15
mat<-as.data.frame(matrix(NA,nrow=(knn.kmax+tree.size.max),ncol=cv+2))
mat[1:knn.kmax,1]<-"knn"
mat[(knn.kmax+1):(knn.kmax+tree.size.max),1]<-"tree"
mat[1:knn.kmax,2]<-1:knn.kmax
mat[(knn.kmax+1):(knn.kmax+tree.size.max),2]<-1:tree.size.max
for (j in 1:cv){
split<-sample(c(T,F), size=n, replace = T, prob = c(p,1-p))
#metodo knn
for (i in 1:knn.kmax){
set.seed(42)
knn.pred <- knn(train=glass[split,-k], test=glass[!split,-k], cl=labels[split], k = i)
mat[i,j+2]<-mean(knn.pred==labels[!split])
}
#metodo alberi
for (i in 1:tree.size.max){
set.seed(42) #TODO metodo previsione alberi con le varie size (GERVI TUTTO TUO)
#mat[(i+knn.kmax),j+2]<-
}
}
res<-cbind(mat[,c(1,2)],apply(mat[,3:j+2],MARGIN=1,mean)) #possiamo usare median se vogliamo
colnames(res)<-c("metodo","hyperparameter","accuracy")
res
View(res)
